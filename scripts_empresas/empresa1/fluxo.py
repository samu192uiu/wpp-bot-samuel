from flask import jsonify
from .ai_bot import AIBot as _AIBot  # marcado como _ para evitar aviso de 'unused import'
from .agenda import (
    listar_blocos_disponiveis,
    horario_disponivel,
    BLOCOS_HORARIOS
)
from datetime import datetime, date
import re
from collections import OrderedDict

import os, json  # ADICIONE
from decimal import Decimal, ROUND_HALF_UP  # ADICIONE

CAT_PATH = os.path.join(os.path.dirname(__file__), "catalogo.json")

def _load_catalogo():
    try:
        with open(CAT_PATH, "r", encoding="utf-8") as f:
            data = json.load(f)
    except FileNotFoundError:
        return {}

    by_code = {
        str(s.get("code")).strip(): s
        for s in data.get("services", [])
        if s.get("active", True) and s.get("code") is not None
    }
    return by_code

CATALOGO = _load_catalogo()

# Base interna da API (para chamadas dentro do container)
API_INTERNAL_BASE = os.getenv("API_INTERNAL_BASE", "http://api:8000").rstrip("/")

def _fmt_brl(v: float | int) -> str:
    d = Decimal(str(v)).quantize(Decimal("0.01"), rounding=ROUND_HALF_UP)
    # formata como R$ 1.234,56
    s = f"{d:,.2f}".replace(",", "X").replace(".", ",").replace("X", ".")
    return f"R$ {s}"

def _mk_item_from_code(code: str):
    s = CATALOGO.get(str(code))
    if not s:
        return None
    try:
        price = float(s.get("price"))
    except (TypeError, ValueError):
        return None
    return {"title": s["label"], "quantity": 1, "unit_price": price}

    
# ==========================
# Helpers de UI / Texto
# ==========================
EMOJI_TO_NUM = {
    "1Ô∏è‚É£": "1", "2Ô∏è‚É£": "2", "3Ô∏è‚É£": "3", "4Ô∏è‚É£": "4", "5Ô∏è‚É£": "5",
    "6Ô∏è‚É£": "6", "7Ô∏è‚É£": "7", "8Ô∏è‚É£": "8", "9Ô∏è‚É£": "9", "0Ô∏è‚É£": "0"
}

def _chip(n, label):
    nums = {"1":"1Ô∏è‚É£","2":"2Ô∏è‚É£","3":"3Ô∏è‚É£","4":"4Ô∏è‚É£","5":"5Ô∏è‚É£","6":"6Ô∏è‚É£","7":"7Ô∏è‚É£","8":"8Ô∏è‚É£","9":"9Ô∏è‚É£","0":"0Ô∏è‚É£"}
    return f"{nums.get(str(n), str(n))} {label}"

def _norm(txt: str) -> str:
    t = (txt or "").strip()
    for e, n in EMOJI_TO_NUM.items():
        t = t.replace(e, n)
    t = t.replace("\u200b", "").replace("\u200c", "")
    return re.sub(r"\s+", " ", t).strip()

def _caixa(titulo: str, conteudo: str) -> str:
    header = "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
    mid    = "‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£"
    bot    = "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
    return f"{header}\n    {titulo}\n{mid}\n{conteudo}\n{bot}"

def _footer_comandos_inline() -> str:
    return "‚ÑπÔ∏è Comandos r√°pidos:\n   ‚Ä¢ Menu   ‚Ä¢ Voltar   ‚Ä¢ Cancelar   ‚Ä¢ Ajuda   ‚Ä¢ Atendente"

def _footer_tips_sel() -> str:
    return (
        "‚ú® Adicione mais servi√ßos\n"
        "üìù Digite *pronto* para finalizar\n"
        "‚ùå Digite *remover* para tirar um item\n"
        "üßπ Digite *limpar* para esvaziar tudo"
    )

# ==========================
# Estado / Navega√ß√£o
# ==========================
def _get(fluxo_usuario, chat_id):
    if chat_id not in fluxo_usuario:
        fluxo_usuario[chat_id] = {"etapa": "menu", "ctx": {}, "pilha": []}
    fluxo_usuario[chat_id].setdefault("ctx", {})
    fluxo_usuario[chat_id].setdefault("pilha", [])
    return fluxo_usuario[chat_id]

def _push(state, new_state):
    state["pilha"].append(state["etapa"])
    state["etapa"] = new_state

def _goto(state, new_state):
    state["etapa"] = new_state

def _back(state):
    if state["pilha"]:
        state["etapa"] = state["pilha"].pop()
        return True
    return False

def _reset(state):
    state["etapa"] = "menu"
    state["ctx"] = {}
    state["pilha"] = []
    
# ==========================
# Datas
# ==========================
def _parse_data(msg: str) -> date | None:
    m = re.match(r"^\s*(\d{1,2})[/-](\d{1,2})\s*$", msg)
    if not m:
        return None
    d, mth = int(m.group(1)), int(m.group(2))
    now = datetime.now()
    y = now.year
    try:
        dt = date(y, mth, d)
    except ValueError:
        return None
    if dt < now.date():
        try:
            dt = date(y + 1, mth, d)
        except ValueError:
            return None
    return dt

def _is_universal(cmd: str) -> str | None:
    key = _norm(cmd).lower()
    if key in {"menu", "in√≠cio", "inicio"}:
        return "menu"
    if key == "voltar":
        return "voltar"
    if key == "cancelar":
        return "cancelar"
    if key == "ajuda":
        return "ajuda"
    if key in {"atendente", "falar com atendente", "humano"}:
        return "atendente"
    return None

# ==========================
# Cat√°logo de servi√ßos
# ==========================
SERVICOS = OrderedDict([
    ("1", {"slug": "corte social", "label": "Corte social", "emoji": "üíá"}),
    ("2", {"slug": "degrad√™", "label": "Degrad√™", "emoji": "üåÄ"}),
    ("3", {"slug": "sobrancelha", "label": "Sobrancelha", "emoji": "‚ú®"}),
    ("4", {"slug": "barba", "label": "Barba", "emoji": "üßî"}),
])
SERVICOS_BY_NAME = {v["slug"]: k for k, v in SERVICOS.items()}
SERVICOS_BY_NAME.update({v["label"].lower(): k for k, v in SERVICOS.items()})

def _catalogo_texto():
    linhas = []
    for k, v in SERVICOS.items():
        linhas.append(f"  {_chip(k, v['label'])}  {v['emoji']}")
    return "\n".join(linhas)

def _render_carrinho(ids, indent="     "):
    if not ids:
        return f"{indent}‚Äî (vazio)"
    linhas = []
    for sid in ids:
        if sid in SERVICOS:
            linhas.append(f"{indent}{_chip(sid, SERVICOS[sid]['label'])}")
    return "\n".join(linhas)

def _parse_servicos_input(texto: str):
    raw = re.split(r"[,\s]+", _norm(texto).lower())
    found = []
    for token in raw:
        if not token:
            continue
        if token in SERVICOS:
            found.append(token)
            continue
        k = SERVICOS_BY_NAME.get(token)
        if k:
            found.append(k)
    seen, ordered = set(), []
    for x in found:
        if x not in seen:
            seen.add(x)
            ordered.append(x)
    return ordered

# ==========================
# Menu principal
# ==========================
def _send_menu(waha, chat_id):
    titulo = "üíà Barbearia do ERIK"
    conteudo = (
        f"{_chip(1, 'Agendar hor√°rio')}\n"
        f"{_chip(2, 'Ver servi√ßos')}\n"
        f"{_chip(3, 'Ver hor√°rios dispon√≠veis')}\n"
        f"{_chip(4, 'Falar com atendente')}"
    )
    rodape = _footer_comandos_inline()
    msg = _caixa(titulo, conteudo) + "\n\n" + rodape
    waha.send_message(chat_id, msg)

# ==========================
# Router do menu
# ==========================
MENU_ROUTER = {
    "1": "agendar", "agendar": "agendar", "agendamento": "agendar",
    "agendar horario": "agendar", "agendar hor√°rio": "agendar",
    "2": "servicos", "servicos": "servicos", "servi√ßos": "servicos",
    "ver servicos": "servicos", "ver servi√ßos": "servicos",
    "3": "ver_horarios", "ver horarios": "ver_horarios", "ver hor√°rios": "ver_horarios",
    "horarios": "ver_horarios", "hor√°rios": "ver_horarios",
    "4": "atendente", "atendente": "atendente", "falar com atendente": "atendente", "humano": "atendente",
}

TEXTUAL_TRIGGERS = {
    "agendar", "agendamento", "agendar horario", "agendar hor√°rio",
    "servicos", "servi√ßos", "ver servicos", "ver servi√ßos",
    "ver horarios", "ver hor√°rios", "horarios", "hor√°rios",
    "atendente", "falar com atendente", "humano",
}

def _handle_menu_action(escolha: str, estado, ctx, chat_id, waha):
    if escolha == "agendar":
        _push(estado, "selecionar_servicos")
        ctx["servicos"] = []
        titulo = "‚úç Selecione os servi√ßos"
        conteudo = _catalogo_texto()
        msg = _caixa(titulo, conteudo) + "\n\n" + \
            "‚ÑπÔ∏è Dica:\n   envie n√∫meros (ex.: 1,3) ou nomes (ex.: corte social, barba)."
        waha.send_message(chat_id, msg)
        return

    if escolha == "servicos":
        titulo = "üìã Servi√ßos dispon√≠veis"
        conteudo = _catalogo_texto()
        msg = _caixa(titulo, conteudo) + "\n\n" + "Para agendar, escolha 1 no menu ou digite Agendar."
        waha.send_message(chat_id, msg)
        _goto(estado, "menu")
        return

    if escolha == "ver_horarios":
        hoje = date.today()
        ctx["consulta_data"] = hoje
        _goto(estado, "ver_horarios_listar")

        horarios = listar_blocos_disponiveis(hoje, exibir_nomes=True)
        if not horarios or horarios.strip() == "":
            waha.send_message(
                chat_id,
                _caixa(
                    "üìÖ Consulta ‚Äî Hoje",
                    f"N√£o encontrei hor√°rios para {hoje.strftime('%d/%m/%Y')}."
                )
            )
            waha.send_message(
                chat_id,
                _caixa(
                    "‚ÑπÔ∏è Como proceder",
                    "‚Ä¢ Para *agendar*, digite: agendar\n"
                    "‚Ä¢ Para ver outra *data*, envie: DD/MM (ex.: 15/08)\n"
                    "‚Ä¢ Ou digite: menu"
                )
            )
            return

        titulo = f"üìÖ Consulta ‚Äî {hoje.strftime('%d/%m/%Y')}"
        conteudo = (
            f"‚è∞ Dispon√≠veis:\n{horarios}\n\n"
            "Para *agendar*, digite: agendar\n"
            "Para consultar outra *data*, envie: DD/MM (ex.: 15/08)"
        )
        waha.send_message(chat_id, _caixa(titulo, conteudo))
        return

    if escolha == "atendente":
        titulo = "üë®‚Äçüíº Atendente"
        conteudo = "Certo! Um atendente vai te chamar em instantes."
        waha.send_message(chat_id, _caixa(titulo, conteudo))
        _goto(estado, "menu")
        _send_menu(waha, chat_id)
        return

# ==========================
# Fluxo principal
# ==========================
def processar(chat_id, msg, nome_empresa, waha, fluxo_usuario):
    estado = _get(fluxo_usuario, chat_id)
    ctx = estado["ctx"]
    msg_original = msg or ""
    msg_norm = _norm(msg_original)
    msg_lower = msg_norm.lower()

    # 1) Comandos UNIVERSAIS
    uni = _is_universal(msg_original)
    if uni == "menu":
        _reset(estado)
        _send_menu(waha, chat_id)
        return jsonify({"status": "success"}), 200
    if uni == "voltar":
        if _back(estado):
            waha.send_message(chat_id, _caixa("‚Ü©Ô∏è Voltar", "Voltei para a etapa anterior. Vamos continuar?"))
        else:
            waha.send_message(chat_id, _caixa("‚Ü©Ô∏è In√≠cio", "Voc√™ j√° est√° no in√≠cio. Digite menu para recome√ßar."))
        return jsonify({"status": "success"}), 200
    if uni == "cancelar":
        _reset(estado)
        waha.send_message(chat_id, _caixa("‚úÖ Fluxo cancelado", "Voltei ao menu principal."))
        _send_menu(waha, chat_id)
        return jsonify({"status": "success"}), 200
    if uni == "ajuda":
        conteudo = (
            "‚Ä¢ Use menu para voltar ao in√≠cio\n"
            "‚Ä¢ voltar para etapa anterior\n"
            "‚Ä¢ cancelar para encerrar\n"
            "‚Ä¢ atendente para falar com humano\n\n"
            "Ex.: ‚Äúagendar amanh√£ √†s 14h‚Äù"
        )
        waha.send_message(chat_id, _caixa("üÜò Ajuda r√°pida", conteudo))
        return jsonify({"status": "success"}), 200
    if uni == "atendente":
        _reset(estado)
        waha.send_message(chat_id, _caixa("üë©‚Äçüíº Atendente", "Perfeito! Vou te direcionar para um atendente agora."))
        _send_menu(waha, chat_id)
        return jsonify({"status": "success"}), 200

    # 1.1) Comandos r√°pidos de pagamento  (<<< fora do bloco do 'atendente')
    if msg_lower in {"status", "status do pagamento", "pagamento"}:
        from . import agenda
        ag_id = ctx.get("ultimo_agendamento_id")
        if not ag_id:
            waha.send_message(chat_id, _caixa("‚ÑπÔ∏è Status", "N√£o encontrei um pagamento pendente recente. Digite *agendar* para come√ßar."))
            return jsonify({"status": "success"}), 200

        # tenta fun√ß√£o dedicada; se n√£o houver, consulta direto a planilha
        status_txt = None
        if hasattr(agenda, "consultar_status"):
            try:
                status_txt = agenda.consultar_status(ag_id)
            except Exception:
                status_txt = None
        if not status_txt:
            try:
                df = agenda.carregar_agendamentos()
                row = df.loc[df["AgendamentoID"] == ag_id]
                if not row.empty:
                    status_txt = str(row.iloc[0]["Status"])
            except Exception:
                status_txt = None

        if not status_txt:
            waha.send_message(chat_id, _caixa("‚ÑπÔ∏è Status", f"Agendamento {ag_id}\nStatus: _indispon√≠vel agora_."))
        else:
            waha.send_message(chat_id, _caixa("‚ÑπÔ∏è Status do pagamento", f"Agendamento {ag_id}\nStatus: *{status_txt}*"))
        return jsonify({"status": "success"}), 200

    if msg_lower in {"reenviar pix", "reenvia pix", "pix de novo", "pagar agora"}:
        import requests
        from . import agenda
        ag_id = ctx.get("ultimo_agendamento_id")
        payload = ctx.get("ultimo_pix_payload") or {}

        if not ag_id or not payload:
            waha.send_message(chat_id, _caixa("‚ÑπÔ∏è PIX", "N√£o encontrei um pagamento pendente recente. Digite *agendar* para come√ßar."))
            return jsonify({"status": "success"}), 200

        # checa se a reserva ainda est√° v√°lida
        try:
            dt_ref = datetime.fromisoformat(payload["data"]).date()
            if not agenda.horario_disponivel(payload["horario"], dt_ref):
                # pode ser a pr√≥pria reserva pendente; tenta bater pelo id
                bate = False
                if hasattr(agenda, "reserva_bate"):
                    try:
                        bate = agenda.reserva_bate(
                            agendamento_id=ag_id, data_ref=dt_ref, horario_ref=payload["horario"], chat_id=chat_id
                        )
                    except Exception:
                        bate = False
                if not bate:
                    waha.send_message(chat_id, _caixa("‚è∞ Reserva expirada", "Esse hor√°rio n√£o est√° mais dispon√≠vel. Digite *agendar* para refazer."))
                    return jsonify({"status": "success"}), 200
        except Exception:
            pass

        # chama novamente o endpoint PIX
        try:
            resp = requests.post(
                f"{API_INTERNAL_BASE}/mp/{nome_empresa}/pix",
                json={
                    "agendamento_id": ag_id,
                    "chat_id": chat_id,
                    "nome": payload.get("nome") or "Cliente",
                    "insta": payload.get("insta") or "",
                    "data": payload.get("data"),
                    "horario": payload.get("horario"),
                },
                timeout=15
            )
            if resp.status_code == 200:
                data_pix = resp.json()
                qr_code    = data_pix.get("qr_code")
                ticket_url = data_pix.get("ticket_url")

                waha.send_message(chat_id, _caixa("üí≥ Novo PIX", f"Enviei um novo PIX (validade ~20 min).\n\nüåê QR em p√°gina web:\n{ticket_url or '‚Äî indispon√≠vel ‚Äî'}"))
                if qr_code:
                    waha.send_message(chat_id, "üîπ *PIX Copia e Cola* (copie a mensagem abaixo):")
                    waha.send_message(chat_id, qr_code)
            else:
                waha.send_message(chat_id, _caixa("‚ö†Ô∏è PIX", "N√£o consegui gerar agora. Talvez a reserva tenha expirado. Digite *agendar* para refazer."))
        except Exception as e:
            waha.send_message(chat_id, _caixa("‚ö†Ô∏è PIX", f"Erro ao gerar: {e}"))

        return jsonify({"status": "success"}), 200

    # 2) HOTKEYS DO MENU
    escolha = None
    if estado["etapa"] == "menu":
        escolha = MENU_ROUTER.get(msg_lower)
    else:
        if msg_lower in TEXTUAL_TRIGGERS:
            escolha = MENU_ROUTER.get(msg_lower)
    if escolha:
        _handle_menu_action(escolha, estado, ctx, chat_id, waha)
        return jsonify({"status": "success"}), 200

    # 3) Estados
    if estado["etapa"] == "menu":
        _send_menu(waha, chat_id)
        _goto(estado, "menu")
        return jsonify({"status": "success"}), 200

    # ===== Sele√ß√£o de servi√ßos =====
    if estado["etapa"] == "selecionar_servicos":
        carrinho = ctx.get("servicos", [])

        if msg_lower in {"pronto", "finalizar", "ok"}:
            if not carrinho:
                waha.send_message(chat_id, _caixa("‚ö†Ô∏è Aten√ß√£o", "Voc√™ ainda n√£o selecionou nenhum servi√ßo. Escolha ao menos 1."))
                return jsonify({"status": "success"}), 200
            _goto(estado, "solicitar_nome")
            lista = _render_carrinho(carrinho)
            titulo = "üóÇ Servi√ßos selecionados"
            conteudo = f"{lista}"
            msg = _caixa(titulo, conteudo) + "\n\n" + "üßë Por favor, digite seu nome completo.\n(ou digite: pular)"
            waha.send_message(chat_id, msg)
            return jsonify({"status": "success"}), 200

        if msg_lower == "limpar":
            ctx["servicos"] = []
            titulo = "üßπ Sele√ß√£o limpa!"
            conteudo = _catalogo_texto()
            msg = _caixa(titulo, conteudo) + "\n\n" + "Adicione servi√ßos (ex.: 1,3) e digite pronto quando terminar."
            waha.send_message(chat_id, msg)
            return jsonify({"status": "success"}), 200

        mrem = re.match(r"^\s*remover\s+(.+)\s*$", msg_lower)
        if mrem:
            alvo = mrem.group(1).strip()
            ids = _parse_servicos_input(alvo)
            if not ids and alvo:
                for sid, v in SERVICOS.items():
                    if alvo in v["label"].lower() or alvo in v["slug"]:
                        ids = [sid]
                        break
            if not ids:
                waha.send_message(chat_id, _caixa("‚ö†Ô∏è N√£o encontrado", "N√£o encontrei esse servi√ßo para remover. Tente remover 2 ou remover barba."))
                return jsonify({"status": "success"}), 200
            for sid in ids:
                if sid in carrinho:
                    carrinho.remove(sid)
            ctx["servicos"] = carrinho
            titulo = "üóë Removido"
            conteudo = f"üóÇ Agora:\n{_render_carrinho(carrinho)}"
            msg = _caixa(titulo, conteudo) + "\n\n" + _footer_tips_sel()
            waha.send_message(chat_id, msg)
            return jsonify({"status": "success"}), 200

        ids = _parse_servicos_input(msg_lower)
        if not ids:
            waha.send_message(
                chat_id,
                _caixa(
                    "‚ö†Ô∏è N√£o entendi",
                    "Envie n√∫meros (ex.: 1,3) ou nomes (ex.: corte social, barba).\n"
                    "Dica: pronto para finalizar."
                )
            )
            return jsonify({"status": "success"}), 200

        for sid in ids:
            if sid not in carrinho and sid in SERVICOS:
                carrinho.append(sid)
        ctx["servicos"] = carrinho

        titulo = "‚úÖ Adicionado!"
        conteudo = f"üóÇ Sele√ß√£o:\n{_render_carrinho(carrinho)}"
        msg = _caixa(titulo, conteudo) + "\n\n" + _footer_tips_sel()
        waha.send_message(chat_id, msg)
        return jsonify({"status": "success"}), 200

    # ===== Nome =====
    if estado["etapa"] == "solicitar_nome":
        nome_raw = msg_norm
        if nome_raw.lower() in {"pular", "skip"}:
            ctx["nome_cliente"] = "Cliente"
        else:
            if not re.match(r"^[A-Za-z√Ä-√ø'¬¥`^~\- ]{2,}$", nome_raw):
                waha.send_message(chat_id, _caixa("‚ùå Nome inv√°lido", "Envie seu nome completo (somente letras). Ex.: Jo√£o da Silva\n(ou digite: pular)"))
                return jsonify({"status": "success"}), 200
            parts = re.sub(r"\s+", " ", nome_raw.strip()).split(" ")
            lowers = {"de","da","do","dos","das","e","di","du"}
            formatted = []
            for i, p in enumerate(parts):
                p = p.lower()
                formatted.append(p if (i != 0 and p in lowers) else p[:1].upper() + p[1:])
            ctx["nome_cliente"] = " ".join(formatted)

        _goto(estado, "solicitar_insta")
        titulo = "üì∑ Quer aparecer com @ na vitrine?"
        conteudo = "Envie seu @ do Instagram (ex.: @seuuser)\nOu digite: pular"
        waha.send_message(chat_id, _caixa(titulo, conteudo))
        return jsonify({"status": "success"}), 200

    # ===== Instagram (opcional) =====
    if estado["etapa"] == "solicitar_insta":
        handle = msg_norm.strip()
        insta = ""
        if handle.lower() not in {"pular", "skip", ""}:
            if not re.match(r"^@?[A-Za-z0-9._]{1,30}$", handle):
                waha.send_message(chat_id, _caixa("‚ùå @ inv√°lido", "Envie no formato @usuario (letras, n√∫meros, ponto e sublinhado).\nOu digite: pular"))
                return jsonify({"status": "success"}), 200
            handle = handle.lower()
            insta = handle if handle.startswith("@") else f"@{handle}"
        ctx["insta"] = insta

        _goto(estado, "solicitar_data")
        titulo = "üìÖ Informe a data"
        conteudo = "Digite no formato DD/MM (ex.: 12/06)."
        waha.send_message(chat_id, _caixa(titulo, conteudo))
        return jsonify({"status": "success"}), 200

    # ===== Data e hor√°rios =====
    if estado["etapa"] == "solicitar_data":
        dt = _parse_data(msg_norm.replace(" ", ""))
        if not dt:
            waha.send_message(chat_id, _caixa("‚ùå Data inv√°lida", "Use DD/MM (ex.: 12/06)."))
            return jsonify({"status": "success"}), 200

        ctx["data"] = dt
        horarios = listar_blocos_disponiveis(dt, exibir_nomes=True)
        if not horarios or horarios.strip() == "":
            waha.send_message(
                chat_id,
                _caixa("üòï Sem hor√°rios", f"N√£o encontrei hor√°rios para {dt.strftime('%d/%m/%Y')}.\nTente outra data, ou voltar para escolher outra op√ß√£o.")
            )
            return jsonify({"status": "success"}), 200

        _goto(estado, "solicitar_horario")
        titulo = f"‚è∞ Hor√°rios dispon√≠veis ‚Äî {dt.strftime('%d/%m/%Y')}"
        conteudo = f"{horarios}\n\nüëâ Digite o n√∫mero do hor√°rio desejado."
        waha.send_message(chat_id, _caixa(titulo, conteudo))
        return jsonify({"status": "success"}), 200

    if estado["etapa"] == "solicitar_horario":
        try:
            indice = int(msg_norm)
        except ValueError:
            waha.send_message(chat_id, _caixa("‚ùå Entrada inv√°lida", "Digite o n√∫mero do hor√°rio da lista."))
            return jsonify({"status": "success"}), 200

        if not (1 <= indice <= len(BLOCOS_HORARIOS)):
            waha.send_message(chat_id, _caixa("‚ùå N√∫mero inv√°lido", "Digite um dos n√∫meros exibidos."))
            return jsonify({"status": "success"}), 200

        horario_escolhido = BLOCOS_HORARIOS[indice - 1]
        data_sel = ctx.get("data")
        if not data_sel:
            _reset(estado)
            waha.send_message(chat_id, _caixa("‚ö†Ô∏è Ops", "Perdi o contexto da data. Vamos recome√ßar pelo menu."))
            _send_menu(waha, chat_id)
            return jsonify({"status": "success"}), 200

        if not horario_disponivel(horario_escolhido, data_sel):
            horarios = listar_blocos_disponiveis(data_sel, exibir_nomes=True)
            titulo = "‚ùå Hor√°rio indispon√≠vel"
            conteudo = f"O hor√°rio {horario_escolhido} acabou de ser ocupado.\n\n‚è∞ Ainda dispon√≠veis:\n{horarios}\n\nEscolha outro n√∫mero."
            waha.send_message(chat_id, _caixa(titulo, conteudo))
            return jsonify({"status": "success"}), 200

        # Dados do cliente
        nome = ctx.get("nome_cliente", "Cliente")
        serv_ids = ctx.get("servicos", [])
        servicos_label = ", ".join([SERVICOS[s]["label"] for s in serv_ids]) if serv_ids else "Servi√ßo"
        insta = ctx.get("insta", "")

        # Monta itens a partir do cat√°logo (com pre√ßos reais)
        itens = []
        for sid in serv_ids:
            item = _mk_item_from_code(sid)
            if item:
                itens.append(item)

        if not itens:
            waha.send_message(chat_id, _caixa("‚ö†Ô∏è Cat√°logo", "N√£o encontrei pre√ßos para os servi√ßos selecionados. Tente novamente."))
            return jsonify({"status": "success"}), 200

        # Total calculado
        total = round(sum(i["unit_price"] * int(i.get("quantity", 1)) for i in itens), 2)

        # Cria pr√©-agendamento com snapshot dos itens
        from . import agenda
        agendamento_id = agenda.criar_pre_agendamento(
            chat_id=chat_id,
            nome=nome,
            data=data_sel,
            horario=horario_escolhido,
            servicos=itens,   # lista com t√≠tulos e pre√ßos
            insta=insta
        )

        # ===== Gera√ß√£o do PIX (Payments API) e mensagens =====
        import requests

        # guarda no contexto para comandos r√°pidos depois
        ctx["ultimo_agendamento_id"] = agendamento_id
        ctx["ultimo_pix_payload"] = {
            "chat_id": chat_id,
            "nome": nome,
            "insta": insta,
            "data": data_sel.isoformat(),
            "horario": horario_escolhido,
        }

        # monta itens caso ainda n√£o exista a lista (com fallback de pre√ßo)
        serv_ids = ctx.get("servicos", [])
        itens = locals().get("itens") or []
        if not itens:
            itens = []
            for sid in serv_ids:
                if sid in SERVICOS:
                    preco = SERVICOS[sid].get("price", 35.0) if isinstance(SERVICOS[sid], dict) else 35.0
                    itens.append({
                        "title": SERVICOS[sid]["label"],
                        "quantity": 1,
                        "unit_price": float(preco)
                    })

        def _fmt_brl_local(v: float) -> str:
            return ("R$ {:,.2f}".format(float(v))).replace(",", "X").replace(".", ",").replace("X", ".")

        servicos_label = ", ".join([SERVICOS[s]["label"] for s in serv_ids if s in SERVICOS]) or "Servi√ßo"
        linhas = "\n".join([f"- {i['title']}: {_fmt_brl(i.get('unit_price', 0))}" for i in itens]) or "‚Äî"
        total_local = round(sum(float(i.get("unit_price", 0)) * int(i.get("quantity", 1)) for i in itens), 2)


        try:
            resp = requests.post(
                f"{API_INTERNAL_BASE}/mp/{nome_empresa}/pix",
                json={
                    "agendamento_id": agendamento_id,
                    "chat_id": chat_id,
                    "nome": nome,
                    "insta": insta,
                    "data": data_sel.isoformat(),
                    "horario": horario_escolhido,
                },
                timeout=15
            )

            if resp.status_code == 200:
                data_pix = resp.json()
                qr_code    = data_pix.get("qr_code")       # PIX Copia e Cola (string longa)
                ticket_url = data_pix.get("ticket_url")    # P√°gina web com o QR (sem login)

                # 1) Mensagem de resumo (sem o c√≥digo, fica mais limpo)
                titulo = "üí≥ PIX para confirmar"
                conteudo = (
                    f"üë§ Cliente: {nome}\n"
                    f"üíà Servi√ßo(s): {servicos_label}\n"
                    f"üìÖ Data: {data_sel.strftime('%d/%m/%Y')}\n"
                    f"üïí Hor√°rio: {horario_escolhido}\n\n"
                    f"üßæ Itens:\n{linhas}\n"
                    f"Total: {_fmt_brl_local(total_local)}\n\n"
                    f"üåê Prefere escanear o QR?\n{ticket_url or '‚Äî indispon√≠vel ‚Äî'}\n\n"
                    "Assim que o banco confirmar, eu te aviso aqui üëç\n"
                    "_(validade ~20 minutos)_"
                )
                waha.send_message(chat_id, _caixa(titulo, conteudo))

                # 2) Mensagem curta s√≥ com o ‚ÄúPIX Copia e Cola‚Äù para facilitar copiar
                if qr_code:
                    waha.send_message(chat_id, "üîπ *PIX Copia e Cola* (copie a mensagem abaixo):")
                    waha.send_message(chat_id, qr_code)  # <- apenas o c√≥digo, isolado

            else:
                waha.send_message(chat_id, _caixa("‚ö†Ô∏è Erro", "N√£o consegui gerar o PIX agora. Tente novamente."))
        except Exception as e:
            waha.send_message(chat_id, _caixa("‚ö†Ô∏è Erro", f"Ocorreu um problema ao criar o pagamento: {e}"))

        _reset(estado)
        return jsonify({"status": "success"}), 200


    # ===== Ver hor√°rios (consulta sem agendar) =====
    if estado["etapa"] == "ver_horarios_data":
        dt = _parse_data(msg_norm.replace(" ", ""))
        if not dt:
            waha.send_message(chat_id, _caixa("‚ùå Data inv√°lida", "Use DD/MM (ex.: 12/06)."))
            return jsonify({"status": "success"}), 200

        ctx["consulta_data"] = dt
        _goto(estado, "ver_horarios_listar")

        horarios = listar_blocos_disponiveis(dt, exibir_nomes=True)
        if not horarios or horarios.strip() == "":
            waha.send_message(
                chat_id,
                _caixa("üòï Sem hor√°rios", f"N√£o encontrei hor√°rios para {dt.strftime('%d/%m/%Y')}.\nEnvie outra data, voltar ou menu.")
            )
            return jsonify({"status": "success"}), 200

        titulo = f"üìÖ Consulta ‚Äî {dt.strftime('%d/%m/%Y')}"
        conteudo = f"‚è∞ Dispon√≠veis:\n{horarios}\n\nPara agendar, digite agendar.\nOu envie outra data."
        waha.send_message(chat_id, _caixa(titulo, conteudo))
        return jsonify({"status": "success"}), 200

    if estado["etapa"] == "ver_horarios_listar":
        dt_try = _parse_data(msg_norm.replace(" ", ""))
        if dt_try:
            ctx["consulta_data"] = dt_try
            horarios = listar_blocos_disponiveis(dt_try, exibir_nomes=True)
            if not horarios or horarios.strip() == "":
                waha.send_message(
                    chat_id,
                    _caixa("üòï Sem hor√°rios", f"N√£o encontrei hor√°rios para {dt_try.strftime('%d/%m/%Y')}.\nEnvie outra data, voltar ou menu.")
                )
                return jsonify({"status": "success"}), 200

            titulo = f"üìÖ Consulta ‚Äî {dt_try.strftime('%d/%m/%Y')}"
            conteudo = f"‚è∞ Dispon√≠veis:\n{horarios}\n\nPara agendar, digite agendar.\nOu envie outra data."
            waha.send_message(chat_id, _caixa(titulo, conteudo))
            return jsonify({"status": "success"}), 200

        if msg_lower in {"agendar", "quero agendar", "fazer agendamento"}:
            _push(estado, "selecionar_servicos")
            ctx["servicos"] = []
            titulo = "‚úç Selecione os servi√ßos"
            conteudo = _catalogo_texto()
            msg = _caixa(titulo, conteudo) + "\n\n" + \
                "‚ÑπÔ∏è Dica:\n   envie n√∫meros (ex.: 1,3) ou nomes (ex.: corte social, barba)."
            waha.send_message(chat_id, msg)
            return jsonify({"status": "success"}), 200

        waha.send_message(
            chat_id,
            _caixa("‚ÑπÔ∏è Dica", "Para agendar, digite agendar.\nVoc√™ tamb√©m pode enviar outra data (DD/MM), voltar ou menu.")
        )
        return jsonify({"status": "success"}), 200

    # ===== Fallback =====
    _reset(estado)
    waha.send_message(chat_id, _caixa("‚ö†Ô∏è N√£o entendi", "Vamos recome√ßar."))
    _send_menu(waha, chat_id)
    return jsonify({"status": "success"}), 200
